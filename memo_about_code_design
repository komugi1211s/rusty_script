

construct bc:

let code = Code::new();

simple opcode:
code.emit_op(OpCode::A);

simple arithmetic:

code.emit_load(x);
code.emit_load(x);
code.emit_arithmetic(Operator::Add);

If operation:
let branch = code.if_branch();
branch.if();
    branch.emit_x();
    branch.emit_x();
branch.finalize();
code.patch(branch);

If-Else operation:
let branch = code.conditional();

branch.if();
    branch.emit_x();
    branch.emit_x();
branch.else();
    code.emit_binary_var("x", Operator::EqEq, "y");
    let inner_branch = code.if_branch();
    inner_branch.if();
        inner_branch.return();

    inner_branch.else();
        inner_branch.emit_x();
        inner_branch.return();
    inner_branch.finalize();
branch.finalize();
code.commit(&branch);

Function Operation:
let function = code.create_function("new_function");

function.add_argument("a", type);
function.add_argument("b", type);
function.add_argument("c", type);

function.put_rest_of_varargs_in("d");
function.set_rettype(type);

let body = function.body_block();
    body.emit_x();
    body.emit_x();
    body.emit_x();
    body.emit_x();
body.finalize();
function.finalize();

code.commit(&function);


code.conclude_and_compile();


Module Creation:

let code_a = Code::new();
let code_b = Code::new();

code_b.import(code_a); // namespaced as code_a.something

re-namespaced Modules:
let code_a = Code::new();
let code_b = Code::new();

code_b.import_as(code_a, "new_name"); // namespaced as new_name.something

Specific imports:
let code_a = Code::new();
let code_b = Code::new();

code_b.import_it_from(code_a, "something"); // if "something" is not declared as global, spits error




     Expr
+<-- Jump :Done
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
+--> :Done

// If and Else

     Expr
+--- Jump :Else
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
|    ...
| +- Jump to :Done 
+-+> :Else
  |  ...
  |  ...
  |  ...
  |  ...
  |  ...
  |  ...
  |  ...
  +> :Done
