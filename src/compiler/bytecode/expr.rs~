 
use trace::{
    SourceFile,
    err_fatal,
    code_line,
};

use syntax_ast::ast::*;

use super::ir::IRCode;
use super::typecheck::{ TypeArena, TypeContext };
use types::{ Value, Type };

pub fn traverse_expression(
    env: &mut Env,
    ctx: &mut Context,
    ast: &ASTree,
    expression_id: ExprId,
) {
    let expression = ast.get_expr(expression_id);

    use Expr::*;
    match expression {
 	Binary(lhs, rhs, oper) => {
            traverse_expression(env, ctx, ast, *lhs);
            traverse_expression(env, ctx, ast, *rhs);
            ctx.emit_from_oper(*oper);
        }

        Unary(rhs, oper) => {
            traverse_expression(env, ctx, ast, *rhs);
            ctx.emit_from_oper(*oper);
        }

        Literal(ref lit_data)  => emit_constants(env, ctx, lit_data),
        _ => unimplemented!(),
    };
}

fn emit_constants(
    env: &mut Env,
    ctx: &mut Context,
    literal: &Literal
) {
    let lexeme: &str = literal.tok.lexeme.as_ref().expect("リテラルなのにトークンが空");

    match literal.kind {
	LiteralKind::Bool => {
	    match lexeme {
		// TODO - @DumbCode: Hardcoded Index.
		"true"  => ctx.emit_op(IRCode::Const8(1)),
		"false" => ctx.emit_op(IRCode::Const8(2)),
		_ => unreachable!(),
	    };
	}

	LiteralKind::Int => {
	    let value: i64 = match lexeme.parse() {
		Ok(n) => n,
		Err(_) => {
		    err_fatal!(
			src: env.source,
			span: literal.tok.span,
			title: "Broken Integer Literal",
			msg: "整数を期待しましたがパースに失敗しました。"
		    );

		    code_line!(src: env.source, span: literal.tok.span, pad: 2);
		    return;
		}
	    };
	    
	    let index = env.consts.add_const(Value::Int(value));
	    ctx.emit_op(IRCode::Const64(index as u32));
	}

	LiteralKind::Float => {
	    let value: f64 = match lexeme.parse() {
		Ok(n) => n,
		Err(_) => {
		    err_fatal!(
			src: env.source,
			span: literal.tok.span,
			title: "Broken Float Literal",
			msg: "実数を期待しましたがパースに失敗しました。"
		    );

		    code_line!(src: env.source, span: literal.tok.span, pad: 2);
		    return;
		}
	    };
	    
	    let index = env.consts.add_const(Value::Float(value));
	    ctx.emit_op(IRCode::Const64(index as u32));
	}
	_ => unimplemented!(),
    }
}
